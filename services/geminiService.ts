

import { GoogleGenAI, Modality } from "@google/genai";
import { Message, Role, UserSettings } from "../types";
import { GEMINI_MODEL, IMAGEN_MODEL, BASE_SYSTEM_INSTRUCTION, PERSONA_PROMPTS, AI_MODELS, GEMINI_BASE_URL } from "../constants";
import { getGeminiKey } from "./config";

// OPTIMIZATION: Max chat history to send to model to prevent slow response times
const MAX_HISTORY_LENGTH = 30; 

// --- RETRY LOGIC (FIX FOR 429 ERRORS) ---
// If the API says "Quota exceeded" (429), we wait and try again automatically.
const wait = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));

async function callWithRetry<T>(fn: () => Promise<T>, retries = 3, delay = 2000): Promise<T> {
    try {
        return await fn();
    } catch (error: any) {
        // Detect 429 (Too Many Requests) or 503 (Overloaded)
        const status = error.status || error.code;
        const msg = error.message || "";
        
        const isQuotaIssue = status === 429 || msg.includes('429') || msg.includes('quota') || msg.includes('limit');
        const isServerIssue = status === 503;

        if ((isQuotaIssue || isServerIssue) && retries > 0) {
            console.warn(`[AI] Quota/Server busy. Retrying in ${delay}ms... (${retries} attempts left)`);
            await wait(delay);
            // Exponential backoff: 2s -> 4s -> 8s
            return callWithRetry(fn, retries - 1, delay * 2);
        }
        throw error;
    }
}

// --- WAV HEADER UTILITIES ---

const writeString = (view: DataView, offset: number, string: string) => {
  for (let i = 0; i < string.length; i++) {
    view.setUint8(offset + i, string.charCodeAt(i));
  }
};

const addWavHeader = (pcmData: Uint8Array, sampleRate: number, numChannels: number = 1): Uint8Array => {
  const header = new ArrayBuffer(44);
  const view = new DataView(header);
  writeString(view, 0, 'RIFF'); // ChunkID
  view.setUint32(4, 36 + pcmData.length, true); // ChunkSize
  writeString(view, 8, 'WAVE'); // Format
  writeString(view, 12, 'fmt '); // Subchunk1ID
  view.setUint32(16, 16, true); // Subchunk1Size
  view.setUint16(20, 1, true); // AudioFormat (1 = PCM)
  view.setUint16(22, numChannels, true); // NumChannels
  view.setUint32(24, sampleRate, true); // SampleRate
  view.setUint32(28, sampleRate * numChannels * 2, true); // ByteRate
  view.setUint16(32, numChannels * 2, true); // BlockAlign
  view.setUint16(34, 16, true); // BitsPerSample
  writeString(view, 36, 'data'); // Subchunk2ID
  view.setUint32(40, pcmData.length, true); // Subchunk2Size

  const wavFile = new Uint8Array(header.byteLength + pcmData.length);
  wavFile.set(new Uint8Array(header), 0);
  wavFile.set(pcmData, header.byteLength);
  return wavFile;
};

const base64ToUint8Array = (base64: string): Uint8Array => {
  const binaryString = atob(base64);
  const bytes = new Uint8Array(binaryString.length);
  for (let i = 0; i < binaryString.length; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return bytes;
};

const uint8ArrayToBase64 = (bytes: Uint8Array): string => {
  let binary = '';
  const len = bytes.byteLength;
  for (let i = 0; i < len; i++) {
    binary += String.fromCharCode(bytes[i]);
  }
  return btoa(binary);
};

// --- EXISTING CHAT LOGIC ---

// Convert to Gemini History with heavy Base64 culling for older messages
const convertToGeminiHistory = (messages: Message[]): any[] => {
  const recentMessages = messages
    .filter((msg) => !msg.isError && !msg.action) 
    .slice(-MAX_HISTORY_LENGTH); 

  return recentMessages.map((msg, index) => {
      const parts: any[] = [];
      const isLatest = index === recentMessages.length - 1;

      if (msg.text) parts.push({ text: msg.text });
      
      if (msg.role === Role.USER && msg.attachments && msg.attachments.length > 0) {
        msg.attachments.forEach(att => {
          if (att.mimeType.startsWith('image/')) {
              if (isLatest) {
                  parts.push({
                      inlineData: { mimeType: att.mimeType, data: att.data }
                  });
              } else {
                  parts.push({ text: `[User uploaded image: ${att.mimeType}]` });
              }
          } else {
             if (isLatest) {
                 parts.push({
                    inlineData: { mimeType: att.mimeType, data: att.data }
                 });
             } else {
                 parts.push({ text: `[User uploaded file: ${att.mimeType}]` });
             }
          }
        });
      }

      if (msg.role === Role.MODEL && msg.image && msg.image.startsWith('data:')) {
          parts.push({ text: "[Image generated by AI]" });
      }

      return {
        role: msg.role === Role.USER ? 'user' : 'model',
        parts: parts,
      };
    });
};

export const generateOnixImage = async (prompt: string): Promise<string> => {
    // WRAP WITH RETRY
    return callWithRetry(async () => {
        try {
            const apiKey = getGeminiKey();
            if (!apiKey) throw new Error("API Key not configured");

            const ai = new GoogleGenAI({ apiKey, baseUrl: GEMINI_BASE_URL });
            
            const parts = [{ text: prompt }];

            const response = await ai.models.generateContent({
                model: IMAGEN_MODEL,
                contents: {
                    parts: parts
                },
                config: {
                    imageConfig: { aspectRatio: "16:9" } 
                }
            });

            const respParts = response.candidates?.[0]?.content?.parts || [];
            for (const part of respParts) {
                if (part.inlineData) {
                    const base64EncodeString = part.inlineData.data;
                    const mimeType = part.inlineData.mimeType || 'image/png';
                    return `data:${mimeType};base64,${base64EncodeString}`;
                }
            }
            
            const textPart = respParts.find(p => p.text);
            if (textPart) {
                throw new Error(`AI_REFUSAL: ${textPart.text}`); 
            }
            
            throw new Error("No image generated in response");
        } catch (e: any) {
            console.error("Image Gen Error", e);
            if (e.message?.includes("404") || e.status === 404) {
                throw new Error("Model not accessible. (404 Not Found)");
            }
            if (e.message?.includes("SAFETY") || e.toString().includes("SAFETY")) {
                throw new Error("SAFETY_BLOCK");
            }
            throw e;
        }
    });
};

export const generateOfficeAction = async (prompt: string, app: 'doc' | 'sheet' | 'slide', lang: 'en' | 'ru'): Promise<any> => {
    // WRAP WITH RETRY
    return callWithRetry(async () => {
        try {
            const apiKey = getGeminiKey();
            if (!apiKey) throw new Error("API Key not configured");
            const ai = new GoogleGenAI({ apiKey, baseUrl: GEMINI_BASE_URL });

            let systemInstruction = "";
            let responseSchema: any = undefined;
            let mimeType = "application/json";

            if (app === 'doc') {
                systemInstruction = `You are a professional Document Writer. Output strictly HTML content for the body of a document (no <html> or <body> tags, just <h1>, <p>, <ul> etc). Use inline CSS for simple styling. Language: ${lang}.`;
                mimeType = "text/plain"; 
            } else if (app === 'sheet') {
                systemInstruction = `You are a Data Analyst. Generate a spreadsheet. Output strict JSON.`;
                responseSchema = {
                    type: "OBJECT",
                    properties: {
                        data: {
                            type: "ARRAY",
                            items: {
                                type: "ARRAY",
                                items: { type: "STRING" }
                            }
                        }
                    }
                };
            } else if (app === 'slide') {
                systemInstruction = `You are a Creative Director for Keynote/PowerPoint. 
                Generate a stunning presentation structure.
                IMPORTANT: You must define a visual theme (colors, fonts) and specific visual effects (particles, gradients).
                CRITICAL: You MUST include a distinct, descriptive 'imagePrompt' for EVERY single slide in the array. Do not leave it empty.
                Output strict JSON.`;
                
                responseSchema = {
                    type: "OBJECT",
                    properties: {
                        theme: {
                            type: "OBJECT",
                            properties: {
                                backgroundColor: { type: "STRING" }, 
                                textColor: { type: "STRING" }, 
                                accentColor: { type: "STRING" }, 
                                fontFamily: { type: "STRING", enum: ["Inter", "Playfair Display", "Roboto Mono", "Lato"] },
                                particleEffect: { type: "STRING", enum: ["none", "stars", "snow", " embers", "matrix"] }
                            }
                        },
                        slides: {
                            type: "ARRAY",
                            items: {
                                type: "OBJECT",
                                properties: {
                                    title: { type: "STRING" },
                                    content: { type: "STRING" }, 
                                    type: { type: "STRING", enum: ["title", "content", "image_split", "quote"] },
                                    imagePrompt: { type: "STRING", description: "Detailed prompt for AI image generator for background/split. MUST BE UNIQUE PER SLIDE." },
                                    animation: { type: "STRING", enum: ["fade", "slide", "zoom"] }
                                }
                            }
                        }
                    }
                };
            }

            const response = await ai.models.generateContent({
                model: GEMINI_MODEL,
                contents: {
                    role: 'user',
                    parts: [{ text: `Task: ${prompt}` }]
                },
                config: {
                    systemInstruction: systemInstruction,
                    responseMimeType: mimeType,
                    responseSchema: responseSchema
                }
            });

            const text = response.candidates?.[0]?.content?.parts?.[0]?.text || "";
            
            if (app === 'doc') return text;
            return JSON.parse(text);

        } catch (e) {
            console.error("Office Gen Error", e);
            throw e;
        }
    });
};

export const previewVoice = async (voiceName: string, text: string): Promise<string> => {
    // WRAP WITH RETRY
    return callWithRetry(async () => {
        try {
            const apiKey = getGeminiKey();
            const ai = new GoogleGenAI({ apiKey, baseUrl: GEMINI_BASE_URL });

            const response = await ai.models.generateContent({
                model: 'gemini-2.5-flash-preview-tts', 
                contents: [{
                    parts: [{ text: text }]
                }],
                config: {
                    responseModalities: [Modality.AUDIO], 
                    speechConfig: {
                        voiceConfig: {
                            prebuiltVoiceConfig: { voiceName: voiceName }
                        }
                    }
                }
            });

            const parts = response.candidates?.[0]?.content?.parts || [];
            
            for (const part of parts) {
                if (part.inlineData && part.inlineData.data) {
                    const pcmData = base64ToUint8Array(part.inlineData.data);
                    const wavData = addWavHeader(pcmData, 24000, 1);
                    const wavBase64 = uint8ArrayToBase64(wavData);
                    return `data:audio/wav;base64,${wavBase64}`;
                }
            }
            
            const textPart = parts.find(p => p.text);
            if (textPart) {
                console.warn("TTS Refusal:", textPart.text);
                throw new Error(`AI_REFUSAL: ${textPart.text}`);
            }

            throw new Error("No audio generated in response. Check API quota or input.");
        } catch (e) {
            console.error("Voice Preview Error", e);
            throw e;
        }
    });
}

export const generateSpeech = async (text: string, voiceName: string): Promise<string> => {
    return previewVoice(voiceName, text);
};

export const streamOnixResponse = async (
  historyMessages: Message[], 
  userMessage: Message,       
  onChunk: (text: string) => void,
  currentLang: 'en' | 'ru' = 'en',
  userSettings: UserSettings = { style: 'auto', customPrompt: '', theme: 'dark', accent: 'default', selectedModel: 'gti-5' }
): Promise<void> => {
    // NOTE: Streaming with retry is harder because we can't easily "restart" a stream mid-way without UI logic.
    // However, if the stream fails immediately (on start), we can retry.
    
    return callWithRetry(async () => {
      try {
        const apiKey = getGeminiKey();
        if (!apiKey) throw new Error("API Key not configured");
        
        const ai = new GoogleGenAI({ apiKey, baseUrl: GEMINI_BASE_URL });
        
        const currentDateTime = new Date().toLocaleString('en-US', { 
          weekday: 'long', year: 'numeric', month: 'long', day: 'numeric', hour: '2-digit', minute: '2-digit' 
        });

        let systemPrompt = `${BASE_SYSTEM_INSTRUCTION}\n`;
        systemPrompt += `\n${PERSONA_PROMPTS[userSettings.style]}\n`;
        systemPrompt += `\nReply in ${currentLang === 'ru' ? 'Russian' : 'English'}.\n`;
        if (userSettings.customPrompt) {
            systemPrompt += `\nUSER INSTRUCTIONS: "${userSettings.customPrompt}"\n`;
        }
        systemPrompt += `\nCurrent Date/Time: ${currentDateTime}.\n`;

        const pastHistory = convertToGeminiHistory(historyMessages);
        
        const text = userMessage.text?.toLowerCase() || "";
        const isShortMessage = text.length < 20;
        const hasAttachments = userMessage.attachments && userMessage.attachments.length > 0;
        
        const isAnalysisQuery = /find|search|buy|price|analyze|compare|shop|поиск|купить|цена|найди|сравни/i.test(text);
        const hasDomain = /\.(com|ru|net|org|io)/i.test(text);

        const shouldSkipTools = isSimpleGreeting(text, isShortMessage, hasAttachments) && !isAnalysisQuery && !hasDomain;

        const tools = shouldSkipTools ? undefined : [
            { googleSearch: {} }
        ];

        const modelId = AI_MODELS[userSettings.selectedModel] || GEMINI_MODEL;

        const chat = ai.chats.create({
            model: modelId,
            config: {
                systemInstruction: systemPrompt,
                tools: tools, 
            },
            history: pastHistory
        });

        const currentParts: any[] = [];
        if (userMessage.text) {
            currentParts.push({ text: userMessage.text });
        }
        if (userMessage.attachments) {
          userMessage.attachments.forEach(att => {
            currentParts.push({
              inlineData: { mimeType: att.mimeType, data: att.data }
            });
          });
        }

        const messageContent = currentParts.length === 1 && currentParts[0].text 
            ? currentParts[0].text 
            : currentParts;

        // TIMEOUT LOGIC
        const streamPromise = chat.sendMessageStream({ message: messageContent });
        const timeoutPromise = new Promise<never>((_, reject) => 
            setTimeout(() => reject(new Error("Response Timeout: AI took too long to reply.")), 45000)
        );

        const result = await Promise.race([streamPromise, timeoutPromise]);

        for await (const chunk of result) {
            const chunkText = chunk.text;
            if (chunkText) {
                onChunk(chunkText);
            }
        }

      } catch (error) {
        console.error("Gemini Chat Error:", error);
        throw error;
      }
    });
};

const isSimpleGreeting = (text: string, isShort: boolean, hasAttachments: boolean) => {
    if (hasAttachments) return false;
    if (!isShort) return false;
    const safeWords = /^(hi|hello|hey|yo|ok|okay|thanks|thx|bye|good|cool|привет|ку|здравствуйте|спс|ок|пока)$/i;
    return safeWords.test(text.trim());
}
